#![no_std]

mod test;

use soroban_sdk::{
    contract, contractimpl, contracttype, contracterror, contractmeta,log,
    Address, Env, String, Symbol,
};
use stellar_fungible::mintable::mint;
use stellar_fungible::burnable::burn;
use stellar_pausable::{self as pausable, Pausable};
use stellar_pausable_macros::when_not_paused;

/********** Ledger Thresholds **********/

const ONE_DAY_LEDGERS: u32 = 17280; // assumes 5s a ledger

const LEDGER_THRESHOLD_INSTANCE: u32 = ONE_DAY_LEDGERS * 30; // ~ 30 days
const LEDGER_BUMP_INSTANCE: u32 = LEDGER_THRESHOLD_INSTANCE + ONE_DAY_LEDGERS; // ~ 31 days

const LEDGER_THRESHOLD_SHARED: u32 = ONE_DAY_LEDGERS * 45; // ~ 45 days
const LEDGER_BUMP_SHARED: u32 = LEDGER_THRESHOLD_SHARED + ONE_DAY_LEDGERS; // ~ 46 days

const LEDGER_THRESHOLD_USER: u32 = ONE_DAY_LEDGERS * 100; // ~ 100 days
const LEDGER_BUMP_USER: u32 = LEDGER_THRESHOLD_USER + 20 * ONE_DAY_LEDGERS; // ~ 120 days

// Token合约数据键
#[derive(Clone)]
#[contracttype]
pub enum DataKey {
    // Token元数据
    Metadata,
    // 合约管理员
    Admin,
    // 初始化状态
    Initialized,
}

// 黑名单数据键
#[derive(Clone)]
#[contracttype]
pub enum BlacklistDataKey {
    BlackListAddress(Address),
}

// Token元数据结构
#[derive(Clone)]
#[contracttype]
pub struct TokenMetadata {
    pub name: String,
    pub symbol: String,
    pub decimals: u32,
}

// 合约错误类型
#[derive(Clone, Debug, Copy, Eq, PartialEq, PartialOrd, Ord)]
#[contracterror]
#[repr(u32)]
pub enum TokenError {
    // 权限不足
    Unauthorized = 1,
    // 合约已暂停
    Paused = 2,
    // 余额不足
    InsufficientBalance = 3,
    // 无效参数
    InvalidArgument = 4,
    // 合约已初始化
    AlreadyInitialized = 5,
    // 合约未初始化
    NotInitialized = 6,
    // 无效地址
    InvalidAddress = 7,
    // 数量必须为正数
    InvalidAmount = 8,
    // 地址在黑名单中
    AddressBlacklisted = 9,
}

// FungibleToken 合约
#[contract]
pub struct FungibleToken;

#[contractimpl]
impl FungibleToken {
    // 初始化合约
    // 
    // # Arguments
    // * `admin` - 合约管理员地址
    // * `name` - 代币名称
    // * `symbol` - 代币符号
    // * `decimals` - 小数位数
    // 
    // # Errors
    // * `AlreadyInitialized` - 合约已经初始化
    // * `InvalidArgument` - 参数无效
    pub fn initialize(
        env: Env,
        admin: Address,
        name: String,
        symbol: String,
        decimals: u32,
    ) -> Result<(), TokenError> {
        // 检查是否已初始化
        if Self::is_initialized_internal(&env) {
            return Err(TokenError::AlreadyInitialized);
        }

        // 验证参数
        if decimals > 18 {
            return Err(TokenError::InvalidArgument);
        }

        // 验证管理员权限
        admin.require_auth();
        
        // 设置合约管理员
        env.storage().instance().set(&DataKey::Admin, &admin);
        
        // 设置token元数据
        let metadata = TokenMetadata {
            name: name.clone(),
            symbol: symbol.clone(),
            decimals,
        };
        env.storage().instance().set(&DataKey::Metadata, &metadata);
        
        // 标记为已初始化
        env.storage().instance().set(&DataKey::Initialized, &true);

        // 发布初始化事件
        env.events().publish(
            (Symbol::new(&env,"initialize"),),
            (admin.clone(), name, symbol, decimals)
        );

        Ok(())
    }
    
    // 获取token名称
    pub fn name(env: Env) -> String {
        Self::get_metadata(&env).name
    }
    
    // 获取token符号
    pub fn symbol(env: Env) -> String {
        Self::get_metadata(&env).symbol
    }
    
    // 获取小数位数
    pub fn decimals(env: Env) -> u32 {
        Self::get_metadata(&env).decimals
    }
    
    // 获取总供应量
    pub fn total_supply(env: Env) -> i128 {
        stellar_fungible::total_supply(&env)
    }
    
    // 获取账户余额
    pub fn balance_of(env: Env, account: Address) -> i128 {
        stellar_fungible::balance(&env, &account)
    }
    
    // 转账
    // 
    // # Arguments
    // * `from` - 发送方地址
    // * `to` - 接收方地址
    // * `amount` - 转账数量
    // 
    // # Errors
    // * `Paused` - 合约已暂停
    // * `InvalidAmount` - 无效数量
    // * `AddressBlacklisted` - 地址在黑名单中
    pub fn transfer(env: Env, from: Address, to: Address, amount: i128) -> Result<(), TokenError> {
        // 检查是否暂停
        Self::require_not_paused(&env)?;
        
        // 检查黑名单
        Self::require_not_blacklisted(&env, &from)?;
        Self::require_not_blacklisted(&env, &to)?;
        
        // 验证参数
        Self::require_positive_amount(amount)?;
        
        // 使用 OpenZeppelin FungibleToken 转账（它会处理from.require_auth()）
        stellar_fungible::transfer(&env, &from, &to, amount);

        // 发布转账事件
        env.events().publish(
            (Symbol::new(&env,"transfer"),),
            (from, to, amount)
        );

        Ok(())
    }
    
    // 授权转账
    pub fn approve(env: Env, from: Address, spender: Address, amount: i128) -> Result<(), TokenError> {
        // 检查是否暂停
        Self::require_not_paused(&env)?;
        
        // 检查黑名单
        Self::require_not_blacklisted(&env, &from)?;
        
        // 验证参数
        Self::require_non_negative_amount(amount)?;
        
        // 设置授权的有效期为当前ledger + 100 days
        let live_until_ledger = env.ledger().sequence() + LEDGER_THRESHOLD_USER;
        
        // 使用 OpenZeppelin FungibleToken 授权（它会处理from.require_auth()）
        stellar_fungible::approve(&env, &from, &spender, amount, live_until_ledger);

        // 发布授权事件
        env.events().publish(
            (Symbol::new(&env,"approve"),),
            (from, spender, amount, live_until_ledger)
        );

        Ok(())
    }
    
    // 获取授权额度
    pub fn allowance(env: Env, from: Address, spender: Address) -> i128 {
        stellar_fungible::allowance(&env, &from, &spender)
    }
    
    // 代理转账
    pub fn transfer_from(env: Env, spender: Address, from: Address, to: Address, amount: i128) -> Result<(), TokenError> {
        // 检查是否暂停
        Self::require_not_paused(&env)?;
        
        // 检查黑名单
        Self::require_not_blacklisted(&env, &from)?;
        Self::require_not_blacklisted(&env, &to)?;
        
        // 验证参数
        Self::require_positive_amount(amount)?;
        
        // 使用 OpenZeppelin FungibleToken 代理转账（它会处理spender.require_auth()）
        stellar_fungible::transfer_from(&env, &spender, &from, &to, amount);

        // 发布代理转账事件
        env.events().publish(
            (Symbol::new(&env,"transfer_from"),),
            (spender, from, to, amount)
        );

        Ok(())
    }
    
    // 铸造代币（仅管理员）
    pub fn mint(env: Env, to: Address, amount: i128) -> Result<(), TokenError> {
        // 检查是否暂停
        Self::require_not_paused(&env)?;
        
        // 验证参数
        Self::require_positive_amount(amount)?;
        
        // 验证管理员权限（mint函数没有内部授权，需要我们处理）
        let admin = Self::require_admin(&env)?;
        
        // 使用 OpenZeppelin FungibleToken 铸造
        mint(&env, &to, amount);

        // 发布铸造事件
        env.events().publish(
            (Symbol::new(&env,"mint"),),
            (admin, to, amount)
        );

        Ok(())
    }
    
    // 销毁代币
    pub fn burn(env: Env, from: Address, amount: i128) -> Result<(), TokenError> {
        // 检查是否暂停
        Self::require_not_paused(&env)?;
        
        // 验证参数
        Self::require_positive_amount(amount)?;
        
        // 使用 OpenZeppelin FungibleToken 销毁（它会处理from.require_auth()）
        burn(&env, &from, amount);

        // 发布销毁事件
        env.events().publish(
            (Symbol::new(&env,"burn"),),
            (from, amount)
        );

        Ok(())
    }
    
    // 暂停合约（仅管理员）
    pub fn pause(env: Env) -> Result<(), TokenError> {
        let admin = Self::require_admin_address(&env)?;
        
        // 使用OpenZeppelin的pause函数，它会处理授权验证
        stellar_pausable::pause(&env, &admin);

        // 发布暂停事件
        env.events().publish(
            (Symbol::new(&env,"pause"),),
            admin
        );

        Ok(())
    }
    
    // 恢复合约（仅管理员）
    pub fn unpause(env: Env) -> Result<(), TokenError> {
        let admin = Self::require_admin_address(&env)?;
        
        // 使用OpenZeppelin的unpause函数，它会处理授权验证
        stellar_pausable::unpause(&env, &admin);

        // 发布恢复事件
        env.events().publish(
            (Symbol::new(&env,"unpause"),),
            admin
        );

        Ok(())
    }
    
    // 检查是否暂停
    pub fn is_paused(env: Env) -> bool {
        stellar_pausable::paused(&env)
    }
    
    // 获取合约管理员
    pub fn admin(env: Env) -> Option<Address> {
        env.storage().instance().get(&DataKey::Admin)
    }
    
    // 转移管理员权限（仅管理员）
    pub fn transfer_admin(env: Env, new_admin: Address) -> Result<(), TokenError> {
        let current_admin = Self::require_admin(&env)?;
        env.storage().instance().set(&DataKey::Admin, &new_admin);
        // 发布管理员权限转移事件
        env.events().publish(
            (Symbol::new(&env,"admin_transfer"),),
            (current_admin, new_admin)
        );

        Ok(())
    }

    // ==================== 黑名单功能 ====================
    
    // 添加地址到黑名单（仅管理员）
    pub fn add_to_blacklist(env: Env, address: Address) -> Result<(), TokenError> {
        let admin = Self::require_admin(&env)?;
        
        // 添加到黑名单
        Self::add_blacklist(&env, &address);
        
        // 发布黑名单添加事件
        env.events().publish(
            (Symbol::new(&env,"blacklist_add"),),
            (admin, address)
        );

        Ok(())
    }
    
    // 从黑名单移除地址（仅管理员）
    pub fn remove_from_blacklist(env: Env, address: Address) -> Result<(), TokenError> {
        let admin = Self::require_admin(&env)?;
        
        // 从黑名单移除
        Self::remove_blacklist(&env, &address);
        
        // 发布黑名单移除事件
        env.events().publish(
            (Symbol::new(&env,"blacklist_remove"),),
            (admin, address)
        );

        Ok(())
    }
    
    // 检查地址是否在黑名单中
    pub fn is_blacklisted(env: Env, address: Address) -> bool {
        Self::is_blacklist(&env, &address)
    }

    // 检查合约是否已初始化
    pub fn is_initialized(env: Env) -> bool {
        Self::is_initialized_internal(&env)
    }
    
    // ==================== 内部辅助函数 ====================
    
    // 检查合约是否已初始化
    fn is_initialized_internal(env: &Env) -> bool {
        env.storage().instance().get(&DataKey::Initialized).unwrap_or(false)
    }
    
    // 获取token元数据
    fn get_metadata(env: &Env) -> TokenMetadata {
        env.storage().instance()
            .get(&DataKey::Metadata)
            .unwrap_or(TokenMetadata {
                name: String::from_str(env, "Unknown"),
                symbol: String::from_str(env, "UNK"),
                decimals: 18,
            })
    }
    
    // 要求调用者是管理员并返回管理员地址
    fn require_admin(env: &Env) -> Result<Address, TokenError> {
        let admin: Address = env.storage().instance()
            .get(&DataKey::Admin)
            .ok_or(TokenError::NotInitialized)?;
        admin.require_auth();
        Ok(admin)
    }

    // 获取管理员地址（不进行授权验证）
    fn require_admin_address(env: &Env) -> Result<Address, TokenError> {
        env.storage().instance()
            .get(&DataKey::Admin)
            .ok_or(TokenError::NotInitialized)
    }

    // 要求合约未暂停
    fn require_not_paused(env: &Env) -> Result<(), TokenError> {
        if stellar_pausable::paused(env) {
            return Err(TokenError::Paused);
        }
        Ok(())
    }

    // 要求数量为正数
    fn require_positive_amount(amount: i128) -> Result<(), TokenError> {
        if amount <= 0 {
            return Err(TokenError::InvalidAmount);
        }
        Ok(())
    }

    // 要求数量为非负数
    fn require_non_negative_amount(amount: i128) -> Result<(), TokenError> {
        if amount < 0 {
            return Err(TokenError::InvalidAmount);
        }
        Ok(())
    }
    
    // 要求地址不在黑名单中
    fn require_not_blacklisted(env: &Env, address: &Address) -> Result<(), TokenError> {
        if Self::is_blacklist(env, address) {
            return Err(TokenError::AddressBlacklisted);
        }
        Ok(())
    }
    
    // ==================== 黑名单内部函数 ====================
    
    // 添加地址到黑名单
    fn add_blacklist(env: &Env, address: &Address) {
        env.storage().instance().set(&BlacklistDataKey::BlackListAddress(address.clone()), &true);
    }
    
    // 从黑名单移除地址
    fn remove_blacklist(env: &Env, address: &Address) {
        env.storage().instance().remove(&BlacklistDataKey::BlackListAddress(address.clone()));
    }
    
    // 检查地址是否在黑名单中
    fn is_blacklist(env: &Env, address: &Address) -> bool {
        env.storage().instance()
            .get(&BlacklistDataKey::BlackListAddress(address.clone()))
            .unwrap_or(false)
    }
}
